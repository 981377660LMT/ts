TypeScript 类型体操通关秘籍
https://juejin.cn/book/7047524421182947366/section/7048460240966123559?utm_source=profile_book

1. 类型检查可以在运行时做，也可以运行之前的编译期做。这是两种不同的类型，前者叫做动态类型检查，后者叫做静态类型检查。
   两种类型检查各有优缺点。

   - 动态类型检查 在源码中不保留类型信息，对某个变量赋什么值、做什么操作都是允许的，写代码很灵活。但这也埋下了类型不安全的隐患，比如对 string 做了乘除，对 Date 对象调用了 exec 方法，这些都是运行时才能检查出来的错误。其中，最常见的错误应该是 “null is not an object”、“undefined is not a function” 之类的了，写代码时没发现类型不匹配，到了运行的时候才发现，就会有很多这种报错。
   - 静态类型检查则是在源码中保留类型信息，声明变量要指定类型，对变量做的操作要和类型匹配，会有专门的编译器在编译期间做检查。

2. 这里的 & string 可能大家会迷惑，解释一下：

因为索引类型（对象、class 等）可以用 string、number 和 symbol 作为 key，这里 keyof T 取出的索引就是 string | number | symbol 的联合类型，和 string 取交叉部分就只剩下 string 了。就像前面所说，`交叉类型会把同一类型做合并，不同类型舍弃`。
**可以理解为推断过程中的 as**

3. 顺口溜

- 提取：模式匹配做提取
- 变换：重新构造做变换
- 循环：递归复用做循环
- 计数：数组长度做计数
- 简化：联合分散可简化
  联合类型遵从分配律
  type T<{ a: string } | { b: number }> 实际上等价于 type T<{ a: string }> | type T<{ b: number }>。

4. ParseQueryString
   a=1&b=2&c=3&d=4，这样的字符串明显是 query param 个数不确定的，遇到数量不确定的问题，条件反射的就要想到递归：
